{"version":3,"sources":["node_modules/split.js/dist/split.es.js"],"names":["Split","global","window","document","addEventListener","removeEventListener","getBoundingClientRect","gutterStartDragging","aGutterSize","bGutterSize","HORIZONTAL","NOOP","isIE8","attachEvent","calc","filter","prefix","el","createElement","style","cssText","length","shift","isString","v","String","elementOrSelector","ele","querySelector","Error","getOption","options","propName","def","value","undefined","getGutterSize","gutterSize","isFirst","isLast","gutterAlign","defaultGutterFn","i","gutterDirection","gut","className","defaultElementStyleFn","dim","size","gutSize","defaultGutterStyleFn","obj","idsOption","ids","dimension","clientAxis","position","positionEnd","clientSize","elements","Array","from","firstElement","parent","parentNode","parentStyle","getComputedStyle","parentFlexDirection","flexDirection","sizes","map","minSize","minSizes","isArray","expandToMin","snapOffset","dragInterval","direction","cursor","gutter","elementStyle","gutterStyle","setElementSize","Object","keys","forEach","prop","getSizes","element","getMousePosition","e","touches","adjust","offset","a","b","percentage","calculateSizes","aBounds","bBounds","start","end","trimToMin","sizesToTrim","parentSize","innerSize","computedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","reduce","excessPixels","toSpare","pixelSizes","pixelSize","elementGutterSize","elementMinSize","push","newPixelSize","takenPixels","Math","min","startDragging","button","self","dragging","preventDefault","move","drag","dragOffset","round","call","bind","stop","stopDragging","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","body","pairs","adjustToMin","pair","setSizes","newSizes","trimmed","newSize","destroy","preserveStyles","preserveGutter","removeChild","id","temp","gutterElement","setGutterSize","insertBefore","computedSize","collapse"],"mappings":";;AAmwBeA,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EA/vBf,IAAIC,EAASC,OACTC,EAAWF,EAAOE,SAIlBC,EAAmB,mBACnBC,EAAsB,sBACtBC,EAAwB,wBACxBC,EAAsB,KACtBC,EAAc,KACdC,EAAc,KACdC,EAAa,aACbC,EAAO,WAAqB,OAAA,GAI5BC,EAAQX,EAAOY,cAAgBZ,EAAOG,GAOtCU,EAAQ,CAAC,GAAI,WAAY,QAAS,OACjCC,OAAO,SAAUC,GACVC,IAAAA,EAAKd,EAASe,cAAc,OAGzB,OAFPD,EAAGE,MAAMC,QAAU,SAAWJ,EAAS,cAE9BC,EAAGE,MAAME,SAErBC,QAAW,OAGZC,EAAW,SAAUC,GAAY,MAAa,iBAANA,GAAkBA,aAAaC,QAKvEC,EAAoB,SAAUT,GAC1BM,GAAAA,EAASN,GAAK,CACVU,IAAAA,EAAMxB,EAASyB,cAAcX,GAC7B,IAACU,EACK,MAAA,IAAIE,MAAO,YAAcZ,EAAK,gCAEjCU,OAAAA,EAGJV,OAAAA,GAIPa,EAAY,SAAUC,EAASC,EAAUC,GACrCC,IAAAA,EAAQH,EAAQC,GAChBE,YAAUC,IAAVD,EACOA,EAEJD,GAGPG,EAAgB,SAAUC,EAAYC,EAASC,EAAQC,GACnDF,GAAAA,EAAS,CACLE,GAAgB,QAAhBA,EACO,OAAA,EAEPA,GAAgB,WAAhBA,EACOH,OAAAA,EAAa,OAErB,GAAIE,EAAQ,CACXC,GAAgB,UAAhBA,EACO,OAAA,EAEPA,GAAgB,WAAhBA,EACOH,OAAAA,EAAa,EAIrBA,OAAAA,GAIPI,EAAkB,SAAUC,EAAGC,GAC3BC,IAAAA,EAAMzC,EAASe,cAAc,OAE1B0B,OADPA,EAAIC,UAAY,iBAAmBF,EAC5BC,GAGPE,EAAwB,SAAUC,EAAKC,EAAMC,GACzC9B,IAAAA,EAAQ,GAYLA,OAVFI,EAASyB,GAOV7B,EAAM4B,GAAOC,EAHT7B,EAAM4B,GAHLnC,EAGYoC,EAAO,IAFPlC,EAAO,IAAMkC,EAAO,OAASC,EAAU,MAQrD9B,GAGP+B,EAAuB,SAAUH,EAAKE,GAClCE,IAAAA,EAEMA,OAAAA,EAAM,IAAQJ,GAAQE,EAAU,KAAOE,GA8BjDnD,EAAQ,SAAUoD,EAAWrB,QACZ,IAAZA,IAAqBA,EAAU,IAEhCsB,IACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EANAN,EAAMD,EASNQ,MAAMC,OACNR,EAAMO,MAAMC,KAAKR,IAMjBS,IACAC,EADerC,EAAkB2B,EAAI,IACfW,WACtBC,EAAcC,iBAAmBA,iBAAiBH,GAAU,KAC5DI,EAAsBF,EAAcA,EAAYG,cAAgB,KAGhEC,EAAQvC,EAAUC,EAAS,UAAYsB,EAAIiB,IAAI,WAAqB,OAAA,IAAMjB,EAAIhC,SAI9EkD,EAAUzC,EAAUC,EAAS,UAAW,KACxCyC,EAAWZ,MAAMa,QAAQF,GAAWA,EAAUlB,EAAIiB,IAAI,WAAqBC,OAAAA,IAG3EG,EAAc5C,EAAUC,EAAS,eAAe,GAChDM,EAAaP,EAAUC,EAAS,aAAc,IAC9CS,EAAcV,EAAUC,EAAS,cAAe,UAChD4C,EAAa7C,EAAUC,EAAS,aAAc,IAC9C6C,EAAe9C,EAAUC,EAAS,eAAgB,GAClD8C,EAAY/C,EAAUC,EAAS,YAAarB,GAC5CoE,EAAShD,EACTC,EACA,SACA8C,IAAcnE,EAAa,aAAe,cAE1CqE,EAASjD,EAAUC,EAAS,SAAUU,GACtCuC,EAAelD,EACfC,EACA,eACAe,GAEAmC,EAAcnD,EAAUC,EAAS,cAAemB,GA8B3CgC,SAAAA,EAAejE,EAAI+B,EAAMC,EAASP,GAKnCvB,IAAAA,EAAQ6D,EAAa1B,EAAWN,EAAMC,EAASP,GAEnDyC,OAAOC,KAAKjE,GAAOkE,QAAQ,SAAUC,GAEjCrE,EAAGE,MAAMmE,GAAQnE,EAAMmE,KAatBC,SAAAA,IACE5B,OAAAA,EAASW,IAAI,SAAUkB,GAAkBA,OAAAA,EAAQxC,OAKnDyC,SAAAA,EAAiBC,GAClB,MAAA,YAAaA,EAAYA,EAAEC,QAAQ,GAAGpC,GACnCmC,EAAEnC,GASJqC,SAAAA,EAAOC,GACRC,IAAAA,EAAInC,EAAS,KAAKmC,GAClBC,EAAIpC,EAAS,KAAKoC,GAClBC,EAAaF,EAAE9C,KAAO+C,EAAE/C,KAE5B8C,EAAE9C,KAAQ6C,EAAS,KAAK7C,KAAQgD,EAChCD,EAAE/C,KAAOgD,EAAcH,EAAS,KAAK7C,KAAQgD,EAE7Cd,EAAeY,EAAEN,QAASM,EAAE9C,KAAM,KAAKxC,GAAcsF,EAAEpD,GACvDwC,EAAea,EAAEP,QAASO,EAAE/C,KAAM,KAAKvC,GAAcsF,EAAErD,GAqElDuD,SAAAA,IAEDH,IAAAA,EAAInC,EAAS,KAAKmC,GAAGN,QACrBO,EAAIpC,EAAS,KAAKoC,GAAGP,QAErBU,EAAUJ,EAAExF,KACZ6F,EAAUJ,EAAEzF,KAEX0C,KAAAA,KACDkD,EAAQ5C,GACR6C,EAAQ7C,GACR,KAAK9C,GACL,KAAKC,GACJ2F,KAAAA,MAAQF,EAAQ1C,GAChB6C,KAAAA,IAAMH,EAAQzC,GAiCd6C,SAAAA,EAAUC,GAGXC,IAAAA,EAjCCC,SAAUjB,GAGX,IAACtB,iBAA2B,OAAA,KAE5BwC,IAAAA,EAAgBxC,iBAAiBsB,GAEjC,IAACkB,EAAwB,OAAA,KAEzB1D,IAAAA,EAAOwC,EAAQ9B,GAEfV,OAAS,IAATA,EAAqB,KAGrBA,GADA6B,IAAcnE,EAEViG,WAAWD,EAAcE,aACzBD,WAAWD,EAAcG,cAGzBF,WAAWD,EAAcI,YACzBH,WAAWD,EAAcK,eAahBN,CAAU1C,GACvByC,GAAe,OAAfA,EACOD,OAAAA,EAGP/B,GAAAA,EAASwC,OAAO,SAAUlB,EAAGC,GAAYD,OAAAA,EAAIC,GAAM,GAAKS,EACjDD,OAAAA,EAKPU,IAAAA,EAAe,EACfC,EAAU,GAEVC,EAAaZ,EAAYjC,IAAI,SAAUtB,EAAMN,GAEzC0E,IAAAA,EAAaZ,EAAaxD,EAAQ,IAClCqE,EAAoBjF,EACpBC,EACM,IAANK,EACAA,IAAM6D,EAAYlF,OAAS,EAC3BmB,GAEA8E,EAAiB9C,EAAS9B,GAAK2E,EAI/BD,OAAAA,EAAYE,GACZL,GAAgBK,EAAiBF,EACjCF,EAAQK,KAAK,GACND,IAIXJ,EAAQK,KAAKH,EAAYE,GAClBF,KAIPH,OAAiB,IAAjBA,EACOV,EAGJY,EAAW7C,IAAI,SAAU8C,EAAW1E,GACnC8E,IAAAA,EAAeJ,EAIfH,GAAAA,EAAe,GAAKC,EAAQxE,GAAKuE,EAAe,EAAG,CAC/CQ,IAAAA,EAAcC,KAAKC,IACnBV,EACAC,EAAQxE,GAAKuE,GAIjBA,GAAgBQ,EAChBD,EAAeJ,EAAYK,EAIvBD,OAAAA,EAAehB,EAAc,MAkDpCoB,SAAAA,EAAclC,GAEf,KAAA,WAAYA,GAAkB,IAAbA,EAAEmC,QAAnB,CAKAC,IACAhC,EAAInC,EADG,KACWmC,GAAGN,QACrBO,EAAIpC,EAFG,KAEWoC,GAAGP,QAFd,KAKDuC,UACNjG,EAAUC,EAAS,cAAepB,EAAlCmB,CAAwCyD,KAI5CG,EAAEsC,iBAVS,KAaND,UAAW,EAbL,KAiBNE,KA5OAC,SAAKxC,GACNG,IAAAA,EACAC,EAAInC,EAAS,KAAKmC,GAClBC,EAAIpC,EAAS,KAAKoC,GAEjB,KAAKgC,WAKVlC,EACIJ,EAAiBC,GACjB,KAAKU,OACJ,KAAK5F,GAAe,KAAK2H,YAE1BvD,EAAe,IACfiB,EAAS6B,KAAKU,MAAMvC,EAASjB,GAAgBA,GAM7CiB,GAAUC,EAAEvB,QAAUI,EAAa,KAAKnE,GACxCqF,EAASC,EAAEvB,QAAU,KAAK/D,GAE1BqF,GACA,KAAK7C,MAAQ+C,EAAExB,QAAUI,EAAa,KAAKlE,MAE3CoF,EAAS,KAAK7C,MAAQ+C,EAAExB,QAAU,KAAK9D,KAI3CmF,EAAOyC,KAAK,KAAMxC,GAIlB/D,EAAUC,EAAS,SAAUpB,EAA7BmB,KAwMiBwG,KAjBN,MAAA,KAkBNC,KAtEAC,WACDV,IACAhC,EAAInC,EADG,KACWmC,GAAGN,QACrBO,EAAIpC,EAFG,KAEWoC,GAAGP,QAFd,KAIFuC,UACLjG,EAAUC,EAAS,YAAapB,EAAhCmB,CAAsCyD,KAL/B,KAQNwC,UAAW,EAGhB9H,EAAOI,GAAqB,UAXjB,KAWiCkI,MAC5CtI,EAAOI,GAAqB,WAZjB,KAYkCkI,MAC7CtI,EAAOI,GAAqB,cAbjB,KAaqCkI,MAChDtI,EAAOI,GAAqB,YAdjB,KAcmC4H,MAC9ChI,EAAOI,GAAqB,YAfjB,KAemC4H,MAfnC,KAkBNM,KAAO,KAlBD,KAmBNN,KAAO,KAEZnC,EAAEzF,GAAqB,cAAeM,GACtCmF,EAAEzF,GAAqB,YAAaM,GACpCoF,EAAE1F,GAAqB,cAAeM,GACtCoF,EAAE1F,GAAqB,YAAaM,GAEpCmF,EAAE3E,MAAMsH,WAAa,GACrB3C,EAAE3E,MAAMuH,iBAAmB,GAC3B5C,EAAE3E,MAAMwH,cAAgB,GACxB7C,EAAE3E,MAAMyH,cAAgB,GAExB7C,EAAE5E,MAAMsH,WAAa,GACrB1C,EAAE5E,MAAMuH,iBAAmB,GAC3B3C,EAAE5E,MAAMwH,cAAgB,GACxB5C,EAAE5E,MAAMyH,cAAgB,GAlCb,KAoCN7D,OAAO5D,MAAM2D,OAAS,GApChB,KAqCNf,OAAO5C,MAAM2D,OAAS,GAC3B3E,EAAS0I,KAAK1H,MAAM2D,OAAS,IA+BJwD,KAlBd,MAqBXrI,EAAOG,GAAkB,UArBd,KAqB8BmI,MACzCtI,EAAOG,GAAkB,WAtBd,KAsB+BmI,MAC1CtI,EAAOG,GAAkB,cAvBd,KAuBkCmI,MAC7CtI,EAAOG,GAAkB,YAxBd,KAwBgC6H,MAC3ChI,EAAOG,GAAkB,YAzBd,KAyBgC6H,MAG3CnC,EAAE1F,GAAkB,cAAeO,GACnCmF,EAAE1F,GAAkB,YAAaO,GACjCoF,EAAE3F,GAAkB,cAAeO,GACnCoF,EAAE3F,GAAkB,YAAaO,GAEjCmF,EAAE3E,MAAMsH,WAAa,OACrB3C,EAAE3E,MAAMuH,iBAAmB,OAC3B5C,EAAE3E,MAAMwH,cAAgB,OACxB7C,EAAE3E,MAAMyH,cAAgB,OAExB7C,EAAE5E,MAAMsH,WAAa,OACrB1C,EAAE5E,MAAMuH,iBAAmB,OAC3B3C,EAAE5E,MAAMwH,cAAgB,OACxB5C,EAAE5E,MAAMyH,cAAgB,OAzCb,KA4CN7D,OAAO5D,MAAM2D,OAASA,EA5ChB,KA6CNf,OAAO5C,MAAM2D,OAASA,EAC3B3E,EAAS0I,KAAK1H,MAAM2D,OAASA,EAG7BmB,EAAeoC,KAjDJ,MAAA,KAoDNF,WAAa1C,EAAiBC,GApDxB,KAoDkCW,KAzW7CxB,IAAcnE,GACd4C,EAAY,QACZC,EAAa,UACbC,EAAW,OACXC,EAAc,QACdC,EAAa,eACQ,aAAdmB,IACPvB,EAAY,SACZC,EAAa,UACbC,EAAW,MACXC,EAAc,SACdC,EAAa,gBAkWjBW,EAAQiC,EAAUjC,GAsBdyE,IAAAA,EAAQ,GAiGHC,SAAAA,EAAYvD,GACbjD,IAAAA,EAASiD,EAAQ9C,IAAMoG,EAAMzH,OAC7B2H,EAAOzG,EAASuG,EAAMtD,EAAQ9C,EAAI,GAAKoG,EAAMtD,EAAQ9C,GAEzDuD,EAAeoC,KAAKW,GAEhBhG,IAAAA,EAAOT,EACLyG,EAAKhG,KAAOwC,EAAQjB,QAAUyE,EAAKvI,GACnC+E,EAAQjB,QAAUyE,EAAKxI,GAE7BoF,EAAOyC,KAAKW,EAAMhG,GAgBbiG,SAAAA,EAASC,GACVC,IAAAA,EAAU7C,EAAU4C,GACxBC,EAAQ9D,QAAQ,SAAU+D,EAAS1G,GAC3BA,GAAAA,EAAI,EAAG,CACHsG,IAAAA,EAAOF,EAAMpG,EAAI,GAEjBoD,EAAInC,EAASqF,EAAKlD,GAClBC,EAAIpC,EAASqF,EAAKjD,GAEtBD,EAAE9C,KAAOmG,EAAQzG,EAAI,GACrBqD,EAAE/C,KAAOoG,EAETlE,EAAeY,EAAEN,QAASM,EAAE9C,KAAMgG,EAAKxI,GAAcsF,EAAEpD,GACvDwC,EAAea,EAAEP,QAASO,EAAE/C,KAAMgG,EAAKvI,GAAcsF,EAAErD,MAK1D2G,SAAAA,EAAQC,EAAgBC,GAC7BT,EAAMzD,QAAQ,SAAU2D,GAchBM,IAbmB,IAAnBC,EACAP,EAAKjF,OAAOyF,YAAYR,EAAKjE,SAE7BiE,EAAKjE,OAAO1E,GACR,YACA2I,EAAKzI,IAETyI,EAAKjE,OAAO1E,GACR,aACA2I,EAAKzI,MAIU,IAAnB+I,EAAyB,CACrBnI,IAAAA,EAAQ6D,EACR1B,EACA0F,EAAKlD,EAAE9C,KACPgG,EAAKxI,IAGT2E,OAAOC,KAAKjE,GAAOkE,QAAQ,SAAUC,GACjC3B,EAASqF,EAAKlD,GAAGN,QAAQrE,MAAMmE,GAAQ,GACvC3B,EAASqF,EAAKjD,GAAGP,QAAQrE,MAAMmE,GAAQ,QAMnD1E,OA1KJ+C,EAAWN,EAAIiB,IAAI,SAAUmF,EAAI/G,GAEzB8C,IAOAwD,EAPAxD,EAAU,CACVA,QAAS9D,EAAkB+H,GAC3BzG,KAAMqB,EAAM3B,GACZ6B,QAASC,EAAS9B,GAClBA,EAAGA,GAKHA,GAAAA,EAAI,KAEJsG,EAAO,CACHlD,EAAGpD,EAAI,EACPqD,EAAGrD,EACHqF,UAAU,EACVlD,UAAWA,EACXd,OAAQA,IAGPvD,GAAe4B,EAChBC,EACAK,EAAI,GAAM,GACV,EACAF,GAEJwG,EAAKvI,GAAe2B,EAChBC,GACA,EACAK,IAAMW,EAAIhC,OAAS,EACnBmB,GAKwB,gBAAxB2B,GACwB,mBAAxBA,GACF,CACMuF,IAAAA,EAAOV,EAAKlD,EAChBkD,EAAKlD,EAAIkD,EAAKjD,EACdiD,EAAKjD,EAAI2D,EASb,IAAC9I,GAEG8B,EAAI,EAAG,CACHiH,IAAAA,EAAgB5E,EAAOrC,EAAGmC,EAAWW,EAAQA,UAnZpDoE,SAAcD,EAAe1G,EAASP,GACvCvB,IAAAA,EAAQ8D,EAAY3B,EAAWL,EAASP,GAE5CyC,OAAOC,KAAKjE,GAAOkE,QAAQ,SAAUC,GAEjCqE,EAAcxI,MAAMmE,GAAQnE,EAAMmE,KA+Y9BsE,CAAcD,EAAetH,EAAYK,GAGzCsG,EAAKzI,GAAuBqH,EAAcU,KAAKU,GAG/CW,EAAcvJ,GACV,YACA4I,EAAKzI,IAEToJ,EAAcvJ,GACV,aACA4I,EAAKzI,IAGTwD,EAAO8F,aAAaF,EAAenE,EAAQA,SAE3CwD,EAAKjE,OAAS4E,EAsBfnE,OAlBPN,EACIM,EAAQA,QACRA,EAAQxC,KACRZ,EACIC,EACM,IAANK,EACAA,IAAMW,EAAIhC,OAAS,EACnBmB,GAEJE,GAKAA,EAAI,GACJoG,EAAMvB,KAAKyB,GAGRxD,KAgBFH,QAAQ,SAAUG,GACnBsE,IAAAA,EAAetE,EAAQA,QAAQlF,KAAyBgD,GAExDwG,EAAetE,EAAQjB,UACnBG,EACAqE,EAAYvD,GAGZA,EAAQjB,QAAUuF,KAqD1BlJ,EACO,CACHqI,SAAUA,EACVI,QAASA,GAIV,CACHJ,SAAUA,EACV1D,SAAUA,EACVwE,SAAU,SAAkBrH,GACxBqG,EAAYpF,EAASjB,KAEzB2G,QAASA,EACTtF,OAAQA,EACR+E,MAAOA,IAIA9I,EAAAA,EAAAA,QAAAA,QAAAA","file":"split.es.65bb222a.js","sourceRoot":"..","sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\n// and very few assumptions about the user's page layout.\nvar global = window;\nvar document = global.document;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Figure out if we're in IE8 or not. IE8 will still render correctly,\n// but will be static instead of draggable.\nvar isIE8 = global.attachEvent && !global[addEventListener];\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = (['', '-webkit-', '-moz-', '-o-']\n    .filter(function (prefix) {\n        var el = document.createElement('div');\n        el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n        return !!el.style.length\n    })\n    .shift()) + \"calc\";\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        if (!isIE8) {\n            style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n        } else {\n            style[dim] = size + \"%\";\n        }\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize to an array if it isn't already. This allows minSize\n    // to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)();\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // IE9 and above\n        if (!isIE8) {\n            // Create gutter elements for each pair.\n            if (i > 0) {\n                var gutterElement = gutter(i, direction, element.element);\n                setGutterSize(gutterElement, gutterSize, i);\n\n                // Save bound event listener for removal later\n                pair[gutterStartDragging] = startDragging.bind(pair);\n\n                // Attach bound event listener\n                gutterElement[addEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                gutterElement[addEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n\n                parent.insertBefore(gutterElement, element.element);\n\n                pair.gutter = gutterElement;\n            }\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    if (isIE8) {\n        return {\n            setSizes: setSizes,\n            destroy: destroy,\n        }\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\nexport default Split;\n"]}